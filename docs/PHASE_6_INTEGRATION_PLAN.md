# Phase 6: Wine Search Integration Plan

**Version:** 3.1 - Production Ready
**Date:** 12 January 2026
**Status:** Approved, Pending Multi-User Implementation
**Dependency:** Requires Multi-User Implementation (cellar_id) first

---

## Why This Matters

These changes protect data integrity (no duplicates, no wrong IDs), improve user trust (correct matches and provenance), and keep cost/latency predictable as we scale. Without this integration, the Phase 0-5 infrastructure sits unused while the wine add flow continues with 50% incorrect matches and 0% external ID storage.

---

## Goal

Wire Phase 0-5 infrastructure into the wine add/rating flow to improve benchmark metrics:
- Baseline: 50% correct matches, 0% vivino_id stored, 40% missing ratings
- Target: 90%+ correct matches, 100% external IDs stored (when confident match exists), <10% missing ratings

---

## Prerequisites

**This plan depends on Multi-User Implementation being complete:**
- `cellar_id` column must exist on `wines` table
- `cellar_id` scoping must be enforced in routes
- Migration numbering: Phase 6 migrations should be **036+** (after Multi-User 027-035)

---

## Architecture Overview

### Wine Add Orchestrator Pipeline

A single unified flow with explicit stages:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        WINE ADD ORCHESTRATOR                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  Stage 1: FINGERPRINT                                                        │
│  ├─ Generate canonical fingerprint (versioned algorithm)                     │
│  └─ Output: fingerprint string + version                                     │
│                                                                              │
│  Stage 2: CACHE CHECK                                                        │
│  ├─ Query search_cache by (cellar_id, fingerprint, pipeline_version)         │
│  ├─ If cache hit + not expired → skip to Stage 5 with cached data            │
│  └─ If miss → proceed to Stage 3                                             │
│                                                                              │
│  Stage 3: DEDUP CHECK                                                        │
│  ├─ Query: SELECT * FROM wines WHERE fingerprint = ? AND cellar_id = ?       │
│  ├─ If exact match → offer "add bottles to existing"                         │
│  ├─ If similar matches (fuzzy) → show disambiguation UI                      │
│  └─ If no match → proceed to Stage 4                                         │
│                                                                              │
│  Stage 4: EXTERNAL SEARCH (with budget governance)                           │
│  ├─ Check cost budget (max $0.02 per request)                                │
│  ├─ Extraction ladder: structured → regex → page_fetch → unlocker → claude   │
│  ├─ Early stop when high confidence reached + sufficient evidence            │
│  ├─ If multiple plausible matches → store candidates, show top 3 for user    │
│  └─ Output: external_id candidates, ratings[], match_confidence, stop_reason │
│                                                                              │
│  Stage 5: PERSIST                                                            │
│  ├─ Insert wine with fingerprint, fingerprint_version                        │
│  ├─ Insert external_id candidates (status: candidate/confirmed)              │
│  ├─ Insert ratings with provenance                                           │
│  ├─ Set ratings_status based on outcome                                      │
│  └─ Update search_cache with result + TTL                                    │
│                                                                              │
│  Stage 6: METRICS                                                            │
│  └─ Log: latency, cost, extraction_method, match_confidence, stop_reason     │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Critical Implementation Requirements

### 1. Standardise on PostgreSQL/Supabase Native Types

**Why:** SQLite patterns will cause silent failures or performance issues in production.

**Must do:**
- Use `BIGINT GENERATED BY DEFAULT AS IDENTITY` (not `INTEGER PRIMARY KEY`)
- Use `TIMESTAMPTZ DEFAULT NOW()` (not `TIMESTAMP DEFAULT CURRENT_TIMESTAMP`)
- Add indexes on all queryable columns upfront

```sql
-- wines table extensions (cellar_id already exists from Multi-User)
ALTER TABLE wines ADD COLUMN fingerprint TEXT;
ALTER TABLE wines ADD COLUMN fingerprint_version SMALLINT DEFAULT 1;
ALTER TABLE wines ADD COLUMN ratings_status TEXT DEFAULT 'not_attempted'
  CHECK (ratings_status IN ('not_attempted', 'attempted_failed', 'partial', 'complete'));
ALTER TABLE wines ADD COLUMN ratings_last_attempt_at TIMESTAMPTZ;
ALTER TABLE wines ADD COLUMN ratings_attempt_count SMALLINT DEFAULT 0;
ALTER TABLE wines ADD COLUMN ratings_next_retry_at TIMESTAMPTZ;

-- Unique constraint per cellar (partial index for non-null fingerprints)
CREATE UNIQUE INDEX idx_wines_cellar_fingerprint
  ON wines(cellar_id, fingerprint) WHERE fingerprint IS NOT NULL;

-- Dashboard queries
CREATE INDEX idx_wines_cellar_ratings_status ON wines(cellar_id, ratings_status);
```

### 2. Version the Fingerprint Algorithm

**Why:** Any future changes to fingerprint logic will cause false duplicates or missed duplicates without versioning.

**Must do:**
- Store `fingerprint_version` column (start at 1)
- Document which fields are included and how they're normalized
- Handle NV (non-vintage) explicitly as 'nv'
- Sort blend varietals alphabetically

**Version 1 specification:**
```
Format: {producer}|{cuvee}|{varietal}|{vintage}|{country}:{region}

Normalization:
- Lowercase all text
- Remove accents (é → e, ñ → n)
- Remove punctuation except hyphens
- Collapse whitespace, trim
- Sort blend varietals alphabetically
- NV/null vintage → 'nv'

Examples:
kanonkop|pinotage|pinotage|2019|za
cloudy-bay|sauvignon-blanc|sauvignon-blanc|nv|nz:marlborough
```

### 3. Add Margin Rule to Auto-Select Logic

**Why:** Absolute thresholds alone allow auto-selection in close races (91% vs 85%) where the user should choose.

**Must do:**
- Auto-select only if: `topScore >= 0.90 AND (topScore - secondScore) >= 0.15`
- Otherwise show disambiguation UI

```javascript
const AUTO_SELECT_CONFIG = {
  minTopScore: 0.90,
  maxSecondScore: 0.70,
  minMargin: 0.15,
  minEvidenceCount: 2
};

function shouldAutoSelect(matches) {
  if (matches.length === 0) return { autoSelect: false, reason: 'no_matches' };
  if (matches.length === 1) {
    return matches[0].confidence.score >= 0.85
      ? { autoSelect: true, match: matches[0], reason: 'single_high_confidence' }
      : { autoSelect: false, reason: 'single_low_confidence' };
  }

  const [top, second] = matches;
  const margin = top.confidence.score - second.confidence.score;

  if (top.confidence.score >= AUTO_SELECT_CONFIG.minTopScore &&
      second.confidence.score < AUTO_SELECT_CONFIG.maxSecondScore &&
      margin >= AUTO_SELECT_CONFIG.minMargin) {
    return { autoSelect: true, match: top, reason: 'clear_winner' };
  }

  return { autoSelect: false, reason: 'close_race' };
}
```

### 4. Scope Cache by Query Hash and Pipeline Version

**Why:** Without versioning, cache returns stale results when extractors change.

**Must do:**
- Include `query_hash` (hash of normalized input fields)
- Include `pipeline_version` (increment when extraction logic changes)
- Default TTL: 14 days, refresh on hit by 7 days
- Invalidate on manual refresh or pipeline version bump

```sql
CREATE TABLE search_cache (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cellar_id BIGINT NOT NULL REFERENCES cellars(id) ON DELETE CASCADE,
  fingerprint TEXT NOT NULL,
  query_hash TEXT NOT NULL,
  pipeline_version SMALLINT NOT NULL DEFAULT 1,
  search_result JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ NOT NULL,
  last_hit_at TIMESTAMPTZ,
  UNIQUE(cellar_id, fingerprint, pipeline_version)
);

CREATE INDEX idx_search_cache_expires ON search_cache(expires_at);
CREATE INDEX idx_search_cache_cellar ON search_cache(cellar_id);
```

### 5. Store External IDs with Candidate/Confirmed Status

**Why:** Real-world matching is ambiguous. Store candidates, confirm one, keep rejected for audit.

**Must do:**
- Add `status` column: `candidate`, `confirmed`, `rejected`
- Add `selected_by_user` boolean
- Add `evidence` JSONB for signals
- Enforce one confirmed ID per source per wine via partial unique index

```sql
CREATE TABLE wine_external_ids (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wine_id BIGINT NOT NULL REFERENCES wines(id) ON DELETE CASCADE,
  source TEXT NOT NULL,
  external_id TEXT NOT NULL,
  external_url TEXT,
  match_confidence REAL,
  status TEXT NOT NULL DEFAULT 'candidate'
    CHECK (status IN ('candidate', 'confirmed', 'rejected')),
  selected_by_user BOOLEAN DEFAULT FALSE,
  evidence JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_wine_external_ids_confirmed
  ON wine_external_ids(wine_id, source) WHERE status = 'confirmed';
CREATE INDEX idx_wine_external_ids_lookup ON wine_external_ids(external_id, source);
CREATE INDEX idx_wine_external_ids_wine ON wine_external_ids(wine_id);
```

### 6. Store Ratings with Provenance (Update-in-Place)

**Why:** Single rating column loses context. Provenance enables trust and debugging.

**Must do (v1):**
- Store source, rating_value, rating_scale, review_count, captured_at, source_url, extraction_method
- Update-in-place with `UNIQUE(wine_id, source)`
- Track `previous_rating_value` for change detection

**v2 (future):** Add history table if time-series tracking needed.

```sql
CREATE TABLE wine_ratings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  wine_id BIGINT NOT NULL REFERENCES wines(id) ON DELETE CASCADE,
  source TEXT NOT NULL,
  rating_value REAL NOT NULL,
  rating_scale TEXT NOT NULL,
  review_count INTEGER,
  previous_rating_value REAL,
  captured_at TIMESTAMPTZ DEFAULT NOW(),
  source_url TEXT,
  extraction_method TEXT NOT NULL
    CHECK (extraction_method IN ('structured', 'regex', 'unlocker', 'claude', 'manual')),
  UNIQUE(wine_id, source)
);

CREATE INDEX idx_wine_ratings_wine_id ON wine_ratings(wine_id);
CREATE INDEX idx_wine_ratings_source ON wine_ratings(source);
```

### 7. Add Retry Backoff Fields

**Why:** Without backoff, failed retries hammer APIs and waste budget.

**Must do:**
- Add `ratings_last_attempt_at`, `ratings_attempt_count`, `ratings_next_retry_at`
- Implement exponential backoff: 1h → 2h → 4h → 8h → max 7 days
- Manual retry allowed anytime but still increments count
- Max 5 attempts before stopping

```javascript
const RETRY_CONFIG = {
  maxAttempts: 5,
  baseDelayMinutes: 60,
  maxDelayMinutes: 10080,
  backoffMultiplier: 2
};

function calculateNextRetry(attemptCount) {
  const delayMinutes = Math.min(
    RETRY_CONFIG.baseDelayMinutes * Math.pow(RETRY_CONFIG.backoffMultiplier, attemptCount - 1),
    RETRY_CONFIG.maxDelayMinutes
  );
  return new Date(Date.now() + delayMinutes * 60 * 1000);
}
```

### 8. Add Total Budget and Early Stop

**Why:** Prevents runaway costs and unnecessary fetches when already confident.

**Must do:**
- Set max cost per request: $0.02 (2 cents)
- Early stop when confidence >= 0.92 and at least 1 source found
- Log `stop_reason` in metrics: `high_confidence`, `budget_exhausted`, `timeout`, `all_sources_tried`

```javascript
const BUDGET_CONFIG = {
  maxCostCentsPerRequest: 2,
  maxSerpCalls: 3,
  maxUnlockerCalls: 2,
  maxClaudeCalls: 1,
  earlyStopConfidence: 0.92,
  earlyStopMinSources: 1
};
```

### 9. Split Benchmarks: Offline Fixtures + Manual Live Smoke

**Why:** Live web calls make CI flaky. Fixtures ensure deterministic testing.

**Must do:**
- Create `tests/benchmark/` with stored HTML fixtures (10+ wines)
- Golden benchmark runs in CI against fixtures only
- Optional `tests/smoke/` with `describe.skip` for manual live testing
- Run live smoke manually before releases, not in CI

```javascript
// tests/benchmark/goldenWines.test.js - RUNS IN CI
const GOLDEN_WINES = [
  {
    name: 'Kanonkop Pinotage 2019',
    fixture: 'fixtures/vivino-kanonkop-pinotage-2019.html',
    expected: {
      rating: { min: 4.0, max: 4.5 },
      confidence: { min: 0.85 }
    }
  }
];

// tests/smoke/liveSearch.test.js - MANUAL ONLY
describe.skip('Live Search Smoke Tests', () => { ... });
```

### 10. Add Multi-User Isolation Tests

**Why:** New tables must not leak data across cellars.

**Must do:**
- Test that User A cannot access User B's ratings via `/api/wines/:id/ratings`
- Test that User A's cache does not return results for User B
- Enforce cellar_id at service layer, not just route

```javascript
describe('Multi-User Isolation', () => {
  it('User A cannot access User B wine ratings', async () => {
    const wineA = await api.asUser('A').post('/api/wines', testWine);
    const response = await api.asUser('B').get(`/api/wines/${wineA.data.id}/ratings`);
    expect(response.status).toBe(404);
  });
});
```

### 11. Migration and Backfill Strategy for Existing Data

**Why:** Adding unique index on fingerprint will fail if existing wines produce duplicate fingerprints.

**Must do:**
1. **Backfill fingerprints** for all existing wines (batch script)
2. **Detect collisions** where two wines produce same fingerprint
3. **Handle collisions:**
   - Generate collision report listing affected wines
   - Temporarily set `fingerprint = NULL` for duplicates (keeps them out of unique index)
   - Create admin task to manually merge or differentiate
4. **Only then** create the unique index

```sql
-- Backfill script (run before adding unique index)
UPDATE wines
SET fingerprint = generate_fingerprint(wine_name, vintage, country, producer, varietal),
    fingerprint_version = 1
WHERE fingerprint IS NULL;

-- Find collisions (per cellar)
SELECT cellar_id, fingerprint, COUNT(*) as cnt, array_agg(id) as wine_ids
FROM wines
WHERE fingerprint IS NOT NULL
GROUP BY cellar_id, fingerprint
HAVING COUNT(*) > 1;

-- Nullify duplicates for later cleanup (keep first, nullify rest)
-- Manual step based on collision report
```

**Migration order:**
1. Add columns (fingerprint, fingerprint_version, ratings_status, etc.)
2. Run backfill script
3. Generate and review collision report
4. Resolve collisions (merge or nullify duplicates)
5. Create unique index
6. Deploy new code

---

## Metrics Definitions (Clarified)

| Metric | Definition | Notes |
|--------|------------|-------|
| **Correct matches** | Benchmark wines correctly matched to expected external ID | Measured via offline golden benchmark |
| **External IDs stored** | % of wines with `status = 'confirmed'` external ID **when confident match exists** | Wines created via "None of these" or with `ratings_status = 'not_attempted'` are excluded from denominator |
| **Missing ratings** | % of wines with `ratings_status != 'complete'` | Includes `not_attempted`, `attempted_failed`, `partial` |
| **Structured extraction rate** | % of successful extractions where `extraction_method = 'structured'` | Target: 60%+ (reduces Claude costs) |
| **Cache hit rate** | % of searches where `cache_hit = true` | Target: 30%+ after warm-up |
| **Avg cost per search** | `AVG(total_cost_cents) FROM search_metrics` | Target: <$0.02 |
| **Avg latency per add** | `AVG(latency_ms) FROM search_metrics` | Target: <5s |

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/services/wineAddOrchestrator.js` | **NEW** - Unified 6-stage pipeline |
| `src/services/structuredParsers.js` | Add confidence scoring with signals |
| `src/services/wineFingerprint.js` | Add version, document algorithm, handle NV/blends |
| `src/services/searchCache.js` | **NEW** - Cache lookup/store with TTL |
| `src/services/claude.js` | Integrate structured extraction |
| `src/routes/wines.js` | Call orchestrator, add endpoints |
| `src/routes/wineSearch.js` | Add metrics + session context |
| `src/db/migrations/036_phase6_integration.sql` | **NEW** - Schema changes |
| `src/db/scripts/backfill_fingerprints.js` | **NEW** - Backfill + collision detection |
| `public/js/bottles/form.js` | Integrate duplicate check + disambiguation |
| `public/js/bottles/disambiguationModal.js` | **NEW** - Multi-match selection UI |
| `src/config/featureFlags.js` | **NEW** - Feature toggles |

---

## New Endpoints

| Endpoint | Purpose |
|----------|---------|
| `POST /api/wines/check-duplicate` | Fingerprint duplicate check |
| `POST /api/wines/:id/refresh-ratings` | Re-run rating search with backoff |
| `GET /api/wines/:id/ratings` | Get all ratings with provenance |
| `GET /api/wines/:id/external-ids` | Get external ID candidates |
| `POST /api/wines/:id/confirm-external-id` | Confirm a candidate ID |
| `POST /api/wines/:id/set-vivino-url` | Manual Vivino URL entry |
| `GET /api/search/metrics` | Get search cost/performance metrics |

---

## Implementation Steps

### Step 1: Database Migration
**File:** `src/db/migrations/036_phase6_integration.sql`

1. Add columns to wines table
2. Create `wine_external_ids`, `wine_ratings`, `search_cache`, `search_metrics` tables
3. Add all indexes (except unique fingerprint index - added in Step 2)

### Step 2: Backfill and Collision Resolution
**File:** `src/db/scripts/backfill_fingerprints.js`

1. Backfill fingerprints for existing wines
2. Generate collision report
3. Resolve collisions manually
4. Add unique index on (cellar_id, fingerprint)

### Step 3: Update Fingerprint Service
**File:** `src/services/wineFingerprint.js`

1. Add `FINGERPRINT_VERSION = 1`
2. Document algorithm in JSDoc
3. Handle NV, blends, accents
4. Return `{ fingerprint, version }` tuple

### Step 4: Enhance Structured Parsers
**File:** `src/services/structuredParsers.js`

1. Add confidence scoring with weighted signals
2. Add `calculateConfidence(result, query)` helper

### Step 5: Create Search Cache Service
**File:** `src/services/searchCache.js`

1. `lookup()`, `store()`, `invalidate()`, `cleanup()`
2. TTL refresh on hit

### Step 6: Create Wine Add Orchestrator
**File:** `src/services/wineAddOrchestrator.js`

1. Implement 6-stage pipeline
2. Per-stage timeouts with Promise.race
3. Budget tracking with early stop
4. Partial failure handling

### Step 7: Integrate into Routes
**File:** `src/routes/wines.js`

1. Call orchestrator on POST /api/wines
2. Add all new endpoints
3. Enforce cellar scoping

### Step 8: Add Feature Flags
**File:** `src/config/featureFlags.js`

1. Define flags with env var overrides

### Step 9: Create Disambiguation UI
**File:** `public/js/bottles/disambiguationModal.js`

1. Top 3 matches with confidence
2. "None of these" option
3. Manual Vivino URL input

### Step 10: Add Tests
1. Unit tests for orchestrator, parsers, fingerprint, cache, auto-select
2. Golden benchmark with fixtures
3. Concurrency tests
4. Multi-user isolation tests

---

## Estimated Changes

| Component | Lines | New/Modified |
|-----------|-------|--------------|
| `wineAddOrchestrator.js` | ~300 | New |
| `searchCache.js` | ~80 | New |
| `backfill_fingerprints.js` | ~60 | New |
| `structuredParsers.js` | ~100 | Modified |
| `wineFingerprint.js` | ~40 | Modified |
| `wines.js` routes | ~150 | Modified |
| `wineSearch.js` | ~50 | Modified |
| Migration file | ~100 | New |
| `featureFlags.js` | ~50 | New |
| `disambiguationModal.js` | ~180 | New |
| `form.js` | ~80 | Modified |
| Unit tests | ~500 | New |
| Integration tests | ~200 | New |
| Fixtures (HTML) | ~10 files | New |

**Total: ~1,900 lines of code + fixtures**

---

## Definition of Done

Phase 6 is complete when:

- [ ] **Fingerprint unique per cellar enforced in DB** - Unique index exists and no violations
- [ ] **Existing data backfilled** - All wines have fingerprint, collisions resolved
- [ ] **External IDs stored with candidate/confirmed status** - Table exists, workflow confirmed
- [ ] **Add-wine flow has early stop and max cost budget** - Budget config enforced, stop_reason logged
- [ ] **Offline benchmark passes in CI** - `npm run test:benchmark` green with fixtures
- [ ] **Cross-tenant access tests added** - Multi-user isolation tests pass
- [ ] **Feature flags operational** - Can disable any feature via env var
- [ ] **Retry backoff working** - Failed ratings respect exponential backoff
- [ ] **Metrics dashboard queryable** - `search_metrics` table populated with all fields

---

## Verification Checklist

After implementation:

1. **All tests pass:**
   ```bash
   npm run test:unit
   npm run test:integration
   npm run test:benchmark
   ```

2. **Manual verification:**
   - Add new wine → fingerprint generated
   - Add duplicate → disambiguation modal shown
   - Select "None of these" → wine created with `ratings_status = 'not_attempted'`
   - Enter manual Vivino URL → extraction succeeds
   - Check ratings have provenance in DB
   - Verify external_ids have candidate/confirmed status
   - Retry failed rating → backoff respected
   - Verify metrics endpoint returns cost data

3. **Feature flag toggles:**
   - Disable `STRUCTURED_EXTRACTION_ENABLED` → falls back to Claude
   - Disable `DISAMBIGUATION_UI_ENABLED` → auto-selects top match
   - Disable `SEARCH_CACHE_ENABLED` → no cache hits

4. **Multi-user isolation:**
   - User A cannot see User B's ratings via API
   - User A's cache doesn't affect User B

5. **Benchmark metrics:**
   - Correct matches: 90%+
   - External IDs stored (when confident): 100%
   - Missing ratings: <10%
   - Avg cost per search: <$0.02
   - Avg latency: <5s

---

## Tables Added to Multi-User Inventory

Phase 6 adds these tables that need `cellar_id` scoping (add to Multi-User checklist):

| Table | cellar_id via | Notes |
|-------|---------------|-------|
| `wine_external_ids` | FK to wines.id | Inherits cellar scope through wine |
| `wine_ratings` | FK to wines.id | Inherits cellar scope through wine |
| `search_cache` | Direct column | Has own cellar_id column |
| `search_metrics` | Direct column | Has own cellar_id column |

---

*Document created: 12 January 2026*
*Version 3.1 - Production Ready*
*Dependency: Multi-User Implementation must complete first*
