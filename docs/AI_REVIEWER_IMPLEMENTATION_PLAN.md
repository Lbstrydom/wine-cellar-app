# AI Reviewer Implementation Plan

## GPT-5.2 Zone Reconfiguration Reviewer

**Date:** 9 January 2026
**Version:** 1.0
**Status:** Ready for Implementation

---

## 1. Overview

### 1.1 Purpose

Add a GPT-5.2 review layer to validate and patch zone reconfiguration plans generated by Claude. The reviewer acts as a **verifier and patcher**, not a second generator.

### 1.2 Architecture

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│     Claude      │────▶│    GPT-5.2      │────▶│   Deterministic │
│   (Planner)     │     │   (Reviewer)    │     │   (Validator)   │
└─────────────────┘     └─────────────────┘     └─────────────────┘
        │                       │                       │
   Generates plan         Verifies &              Hard constraint
   with reasoning         patches issues          enforcement
```

### 1.3 Design Principles

1. **Reviewer is a verifier/patcher** — not a second generator
2. **Quality over speed** — latency acceptable for better outcomes
3. **Fail-safe** — if reviewer fails, fall back to original plan + deterministic validation
4. **Observable** — comprehensive telemetry for sommelier review
5. **Incremental** — start with zone reconfiguration, expand strategically

---

## 2. Implementation Tasks

### Phase 1: Foundation

#### Task 1.1: Create Telemetry Table Migration

**File:** `src/db/migrations/026_ai_review_telemetry.sql`

```sql
-- AI Review Telemetry for quality tracking and sommelier feedback loop
CREATE TABLE IF NOT EXISTS ai_review_telemetry (
    id BIGSERIAL PRIMARY KEY,

    -- Linkability
    cellar_id TEXT,                          -- For multi-cellar future
    plan_id TEXT NOT NULL,                   -- Links to zone_reconfigurations
    session_id TEXT,                         -- Group related reviews

    -- Timestamps
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    review_started_at TIMESTAMPTZ,
    review_completed_at TIMESTAMPTZ,

    -- Input context
    input_plan_hash TEXT,                    -- SHA256 of input plan JSON
    planner_model TEXT,                      -- e.g., 'claude-sonnet-4'
    input_action_count INTEGER,
    input_summary JSONB,                     -- misplaced_before, bottles_affected, etc.

    -- Reviewer details
    reviewer_model TEXT NOT NULL,            -- e.g., 'gpt-5.2'
    reasoning_effort TEXT,                   -- 'low', 'medium', 'high'
    temperature REAL,
    max_output_tokens INTEGER,

    -- Output
    verdict TEXT NOT NULL,                   -- 'approve', 'patch', 'reject'
    violations_count INTEGER DEFAULT 0,
    patches_count INTEGER DEFAULT 0,
    output_plan_hash TEXT,                   -- SHA256 of output plan JSON
    output_action_count INTEGER,

    -- Detailed results (JSONB for flexibility)
    violations JSONB,                        -- Array of violation objects
    patches JSONB,                           -- Array of patch objects
    reviewer_reasoning TEXT,                 -- GPT-5.2's explanation

    -- Token usage
    prompt_tokens INTEGER,
    completion_tokens INTEGER,
    total_tokens INTEGER,
    reasoning_tokens INTEGER,                -- For reasoning models

    -- Performance
    latency_ms INTEGER,                      -- Total review time

    -- Quality metrics
    stability_score REAL,                    -- 0-1, higher = less churn
    constraint_violations_found INTEGER,

    -- Circuit breaker
    was_fallback BOOLEAN DEFAULT FALSE,      -- True if reviewer failed
    fallback_reason TEXT,

    -- Sommelier feedback (filled in later)
    sommelier_rating INTEGER,                -- 1-5 stars
    sommelier_notes TEXT,
    reviewed_by_sommelier_at TIMESTAMPTZ
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_ai_review_telemetry_plan_id
    ON ai_review_telemetry (plan_id);
CREATE INDEX IF NOT EXISTS idx_ai_review_telemetry_created_at
    ON ai_review_telemetry (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_ai_review_telemetry_verdict
    ON ai_review_telemetry (verdict);
CREATE INDEX IF NOT EXISTS idx_ai_review_telemetry_sommelier_pending
    ON ai_review_telemetry (created_at DESC)
    WHERE sommelier_rating IS NULL;
```

**Acceptance Criteria:**
- [ ] Migration runs without errors on PostgreSQL
- [ ] All indexes created
- [ ] Table accessible via db abstraction layer

---

#### Task 1.2: Create OpenAI Reviewer Service

**File:** `src/services/openaiReviewer.js`

```javascript
/**
 * @fileoverview GPT-5.2 reviewer for zone reconfiguration plans.
 * Uses Structured Outputs for guaranteed schema compliance.
 * @module services/openaiReviewer
 */

import OpenAI from 'openai';
import { z } from 'zod';
import { zodResponseFormat } from 'openai/helpers/zod';
import crypto from 'crypto';

// Feature flag check
const FEATURE_ENABLED = process.env.OPENAI_REVIEW_ZONE_RECONFIG === 'true';

// Circuit breaker state (in-memory for now, Redis-ready interface)
const circuitBreaker = {
  failures: 0,
  lastFailure: null,
  isOpen: false,
  threshold: 3,
  resetTimeMs: 5 * 60 * 1000, // 5 minutes

  recordFailure() {
    this.failures++;
    this.lastFailure = Date.now();
    if (this.failures >= this.threshold) {
      this.isOpen = true;
      console.warn('[OpenAIReviewer] Circuit breaker OPEN after', this.failures, 'failures');
    }
  },

  recordSuccess() {
    this.failures = 0;
    this.isOpen = false;
  },

  canAttempt() {
    if (!this.isOpen) return true;
    // Auto-reset after timeout
    if (Date.now() - this.lastFailure > this.resetTimeMs) {
      this.isOpen = false;
      this.failures = 0;
      console.info('[OpenAIReviewer] Circuit breaker RESET');
      return true;
    }
    return false;
  }
};

// Zod schema for structured output
const ViolationSchema = z.object({
  action_id: z.number().describe('Index of the action in the plan (0-based)'),
  rule: z.string().describe('Which rule was violated'),
  severity: z.enum(['critical', 'warning']).describe('Critical = must fix, Warning = recommended fix'),
  description: z.string().describe('Human-readable explanation')
});

const PatchSchema = z.object({
  action_id: z.number().describe('Index of the action to patch (0-based)'),
  field: z.string().describe('Field name to modify (e.g., "rowNumber", "toZoneId")'),
  old_value: z.union([z.string(), z.number(), z.null()]).describe('Original value'),
  new_value: z.union([z.string(), z.number()]).describe('Corrected value'),
  reason: z.string().describe('Why this patch is needed')
});

const ReviewResultSchema = z.object({
  verdict: z.enum(['approve', 'patch', 'reject']).describe(
    'approve = plan is good, patch = fixable issues found, reject = fundamentally flawed'
  ),
  violations: z.array(ViolationSchema).describe('List of rule violations found'),
  patches: z.array(PatchSchema).describe('Targeted fixes for violations (only if verdict=patch)'),
  reasoning: z.string().describe('Brief explanation of the review decision'),
  stability_score: z.number().min(0).max(1).describe(
    'Estimate of plan stability: 1.0 = minimal disruption, 0.0 = maximum churn'
  ),
  confidence: z.enum(['high', 'medium', 'low']).describe('Reviewer confidence in this assessment')
});

/**
 * Hash a plan for telemetry linkability.
 */
function hashPlan(plan) {
  const str = JSON.stringify(plan, Object.keys(plan).sort());
  return crypto.createHash('sha256').update(str).digest('hex').slice(0, 16);
}

/**
 * Build the review prompt with cellar context.
 */
function buildReviewPrompt(plan, context) {
  const { zones, physicalConstraints, currentState } = context;

  // Build zone allocation map for the reviewer
  const zoneAllocations = zones.map(z => ({
    id: z.id,
    name: z.name,
    actualRows: z.actualAssignedRows,
    rowCount: z.actualAssignedRows?.length || 0
  }));

  return `You are a wine cellar zone configuration reviewer. Your job is to VERIFY a proposed reconfiguration plan, not generate a new one.

## Physical Constraints
- Total rows: ${physicalConstraints.totalRows}
- Slots per row: ${physicalConstraints.slotsPerRow}
- Total capacity: ${physicalConstraints.totalCapacity}

## Current State
- Total bottles: ${currentState.totalBottles}
- Misplaced bottles: ${currentState.misplaced}
- Misplacement rate: ${currentState.misplacementPct}%

## Zone Allocations (ACTUAL current state)
${JSON.stringify(zoneAllocations, null, 2)}

## Rules to Verify
1. **Row Ownership**: A reallocate_row action can ONLY move a row that the fromZone actually owns (check actualRows)
2. **Zone Existence**: All zone IDs must be valid (exist in the zone list)
3. **No Duplicate Rows**: Same row cannot be reallocated multiple times in one plan
4. **Capacity Sanity**: Don't leave a zone with 0 rows if it has bottles
5. **Zone ID Format**: Zone IDs are strings like "chenin_blanc", NOT numbers

## Proposed Plan to Review
${JSON.stringify(plan, null, 2)}

## Your Task
1. Check each action against the rules
2. For violations, determine if they're fixable with a targeted patch
3. Provide a verdict:
   - "approve" if plan is valid
   - "patch" if issues are fixable (provide specific patches)
   - "reject" if fundamentally flawed (e.g., all actions invalid)
4. Calculate stability_score based on how much disruption this plan causes

Remember: You are a VERIFIER. Do not invent new actions or restructure the plan. Only validate and patch.`;
}

/**
 * Review a zone reconfiguration plan using GPT-5.2.
 *
 * @param {Object} plan - The plan from Claude (actions, reasoning, summary)
 * @param {Object} context - Cellar context (zones, constraints, currentState)
 * @param {Object} options - Review options
 * @returns {Promise<Object>} Review result with verdict, violations, patches
 */
export async function reviewReconfigurationPlan(plan, context, options = {}) {
  const startTime = Date.now();
  const planId = options.planId || `plan_${Date.now()}`;
  const inputHash = hashPlan(plan);

  // Check feature flag
  if (!FEATURE_ENABLED) {
    return {
      skipped: true,
      reason: 'Feature flag OPENAI_REVIEW_ZONE_RECONFIG not enabled',
      originalPlan: plan
    };
  }

  // Check circuit breaker
  if (!circuitBreaker.canAttempt()) {
    return {
      skipped: true,
      reason: 'Circuit breaker open due to recent failures',
      originalPlan: plan,
      telemetry: { was_fallback: true, fallback_reason: 'circuit_breaker_open' }
    };
  }

  // Check API key
  if (!process.env.OPENAI_API_KEY) {
    return {
      skipped: true,
      reason: 'OPENAI_API_KEY not configured',
      originalPlan: plan
    };
  }

  const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });

  const reviewPrompt = buildReviewPrompt(plan, context);

  // Configuration
  const config = {
    model: options.model || 'gpt-5.2',
    temperature: options.temperature ?? 0.1,  // Low for deterministic reviews
    max_output_tokens: options.maxOutputTokens || 2000,
    reasoning_effort: options.reasoningEffort || 'medium'
  };

  try {
    // Use Structured Outputs via responses.parse()
    const response = await openai.responses.parse({
      model: config.model,
      input: [
        { role: 'system', content: 'You are a precise wine cellar configuration reviewer.' },
        { role: 'user', content: reviewPrompt }
      ],
      text: {
        format: zodResponseFormat(ReviewResultSchema, 'review_result')
      },
      temperature: config.temperature,
      max_output_tokens: config.max_output_tokens,
      reasoning: {
        effort: config.reasoning_effort
      }
    });

    // Extract structured result (already parsed and validated by Zod)
    const result = response.output_parsed;
    const latencyMs = Date.now() - startTime;

    // Record success
    circuitBreaker.recordSuccess();

    // Build telemetry record
    const telemetry = {
      plan_id: planId,
      input_plan_hash: inputHash,
      planner_model: 'claude-sonnet-4',
      input_action_count: plan.actions?.length || 0,
      input_summary: plan.summary || {},
      reviewer_model: config.model,
      reasoning_effort: config.reasoning_effort,
      temperature: config.temperature,
      max_output_tokens: config.max_output_tokens,
      verdict: result.verdict,
      violations_count: result.violations?.length || 0,
      patches_count: result.patches?.length || 0,
      output_plan_hash: null, // Set after applying patches
      violations: result.violations,
      patches: result.patches,
      reviewer_reasoning: result.reasoning,
      prompt_tokens: response.usage?.input_tokens,
      completion_tokens: response.usage?.output_tokens,
      total_tokens: response.usage?.total_tokens,
      reasoning_tokens: response.usage?.output_tokens_details?.reasoning_tokens,
      latency_ms: latencyMs,
      stability_score: result.stability_score,
      was_fallback: false
    };

    return {
      ...result,
      telemetry,
      originalPlan: plan
    };

  } catch (error) {
    const latencyMs = Date.now() - startTime;
    console.error('[OpenAIReviewer] Error:', error.message);

    // Record failure for circuit breaker
    circuitBreaker.recordFailure();

    return {
      skipped: true,
      reason: `Reviewer error: ${error.message}`,
      originalPlan: plan,
      telemetry: {
        plan_id: planId,
        input_plan_hash: inputHash,
        reviewer_model: config.model,
        latency_ms: latencyMs,
        was_fallback: true,
        fallback_reason: error.message
      }
    };
  }
}

/**
 * Apply patches to a plan, producing a new plan.
 * Uses diff-like patches for transparency.
 *
 * @param {Object} plan - Original plan
 * @param {Array} patches - Array of patch objects
 * @returns {Object} Patched plan with audit trail
 */
export function applyPatches(plan, patches) {
  if (!patches || patches.length === 0) {
    return { ...plan, _patchesApplied: 0 };
  }

  // Deep clone actions
  const patchedActions = JSON.parse(JSON.stringify(plan.actions || []));
  const appliedPatches = [];

  for (const patch of patches) {
    const { action_id, field, old_value, new_value, reason } = patch;

    if (action_id < 0 || action_id >= patchedActions.length) {
      console.warn(`[OpenAIReviewer] Invalid patch action_id: ${action_id}`);
      continue;
    }

    const action = patchedActions[action_id];
    const currentValue = action[field];

    // Verify old_value matches (safety check)
    if (old_value !== null && currentValue !== old_value) {
      console.warn(`[OpenAIReviewer] Patch mismatch for action ${action_id}.${field}: expected ${old_value}, found ${currentValue}`);
      continue;
    }

    // Apply patch
    action[field] = new_value;
    appliedPatches.push({ action_id, field, old_value, new_value, reason });
  }

  return {
    ...plan,
    actions: patchedActions,
    _patchesApplied: appliedPatches.length,
    _patchAudit: appliedPatches
  };
}

/**
 * Save telemetry record to database.
 */
export async function saveTelemetry(db, telemetry) {
  if (!telemetry) return null;

  try {
    const result = await db.prepare(`
      INSERT INTO ai_review_telemetry (
        plan_id, input_plan_hash, planner_model, input_action_count, input_summary,
        reviewer_model, reasoning_effort, temperature, max_output_tokens,
        verdict, violations_count, patches_count, output_plan_hash,
        violations, patches, reviewer_reasoning,
        prompt_tokens, completion_tokens, total_tokens, reasoning_tokens,
        latency_ms, stability_score, was_fallback, fallback_reason,
        review_started_at, review_completed_at
      ) VALUES (
        $1, $2, $3, $4, $5,
        $6, $7, $8, $9,
        $10, $11, $12, $13,
        $14, $15, $16,
        $17, $18, $19, $20,
        $21, $22, $23, $24,
        NOW() - INTERVAL '1 millisecond' * $21, NOW()
      ) RETURNING id
    `).get([
      telemetry.plan_id,
      telemetry.input_plan_hash,
      telemetry.planner_model,
      telemetry.input_action_count,
      JSON.stringify(telemetry.input_summary || {}),
      telemetry.reviewer_model,
      telemetry.reasoning_effort,
      telemetry.temperature,
      telemetry.max_output_tokens,
      telemetry.verdict || 'skipped',
      telemetry.violations_count || 0,
      telemetry.patches_count || 0,
      telemetry.output_plan_hash,
      JSON.stringify(telemetry.violations || []),
      JSON.stringify(telemetry.patches || []),
      telemetry.reviewer_reasoning,
      telemetry.prompt_tokens,
      telemetry.completion_tokens,
      telemetry.total_tokens,
      telemetry.reasoning_tokens,
      telemetry.latency_ms,
      telemetry.stability_score,
      telemetry.was_fallback || false,
      telemetry.fallback_reason
    ]);

    return result?.id;
  } catch (error) {
    console.error('[OpenAIReviewer] Failed to save telemetry:', error.message);
    return null;
  }
}

/**
 * Get circuit breaker status (for monitoring/debugging).
 */
export function getCircuitBreakerStatus() {
  return {
    isOpen: circuitBreaker.isOpen,
    failures: circuitBreaker.failures,
    threshold: circuitBreaker.threshold,
    lastFailure: circuitBreaker.lastFailure,
    resetTimeMs: circuitBreaker.resetTimeMs
  };
}
```

**Acceptance Criteria:**
- [ ] Uses `responses.parse()` with Zod schema (not `JSON.parse`)
- [ ] Low temperature (0.1) for deterministic reviews
- [ ] Circuit breaker with 3-failure threshold, 5-minute reset
- [ ] Diff-like patches with `action_id` and `field`
- [ ] Comprehensive telemetry object returned
- [ ] Graceful fallback on any error

---

#### Task 1.3: Add Feature Flag to Environment

**File:** `.env` (add to existing)

```bash
# OpenAI Reviewer Feature Flags
# Set to 'true' to enable GPT-5.2 review of zone reconfiguration plans
OPENAI_REVIEW_ZONE_RECONFIG=false
```

**Acceptance Criteria:**
- [ ] Feature flag documented
- [ ] Default is `false` (opt-in)

---

### Phase 2: Integration

#### Task 2.1: Integrate Reviewer into Zone Reconfiguration Planner

**File:** `src/services/zoneReconfigurationPlanner.js`

Add the following integration after Claude generates the plan:

```javascript
// Add imports at top
import {
  reviewReconfigurationPlan,
  applyPatches,
  saveTelemetry,
  hashPlan
} from './openaiReviewer.js';
import db from '../db/index.js';

// In generateReconfigurationPlan(), after Claude returns:

async function generateReconfigurationPlan(report, options = {}) {
  // ... existing Claude plan generation code ...

  // After getting plan from Claude or heuristic fallback:
  let finalPlan = plan;
  let reviewTelemetry = null;

  // GPT-5.2 Review Layer
  const reviewContext = {
    zones: zonesWithAllocations,
    physicalConstraints: {
      totalRows: TOTAL_CELLAR_ROWS,
      slotsPerRow: SLOTS_PER_ROW,
      totalCapacity: TOTAL_CELLAR_ROWS * SLOTS_PER_ROW
    },
    currentState: {
      totalBottles,
      misplaced: misplacedBottles,
      misplacementPct
    }
  };

  const planId = `plan_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

  const reviewResult = await reviewReconfigurationPlan(
    plan,
    reviewContext,
    { planId }
  );

  if (!reviewResult.skipped) {
    reviewTelemetry = reviewResult.telemetry;

    if (reviewResult.verdict === 'approve') {
      console.info('[ZoneReconfigPlanner] Plan approved by reviewer');
      finalPlan = plan;
    } else if (reviewResult.verdict === 'patch') {
      console.info(`[ZoneReconfigPlanner] Applying ${reviewResult.patches?.length || 0} patches`);
      finalPlan = applyPatches(plan, reviewResult.patches);

      // Update telemetry with output hash
      if (reviewTelemetry) {
        reviewTelemetry.output_plan_hash = hashPlan(finalPlan);
        reviewTelemetry.output_action_count = finalPlan.actions?.length || 0;
      }
    } else if (reviewResult.verdict === 'reject') {
      console.warn('[ZoneReconfigPlanner] Plan rejected by reviewer:', reviewResult.reasoning);
      // Fall back to original plan - deterministic validator will still run
      finalPlan = plan;
      finalPlan._reviewerRejected = true;
      finalPlan._rejectionReason = reviewResult.reasoning;
    }
  } else {
    console.info('[ZoneReconfigPlanner] Reviewer skipped:', reviewResult.reason);
    reviewTelemetry = reviewResult.telemetry;
  }

  // Save telemetry async (don't block response)
  if (reviewTelemetry) {
    saveTelemetry(db, reviewTelemetry).catch(err => {
      console.error('[ZoneReconfigPlanner] Failed to save telemetry:', err.message);
    });
  }

  // Continue with existing deterministic validation...
  // ... rest of function ...

  return {
    summary: computeSummary(report, finalPlan.actions),
    reasoning: finalPlan.reasoning,
    actions: finalPlan.actions,
    _reviewMetadata: reviewTelemetry ? {
      verdict: reviewTelemetry.verdict,
      patchesApplied: finalPlan._patchesApplied || 0,
      stabilityScore: reviewTelemetry.stability_score,
      latencyMs: reviewTelemetry.latency_ms
    } : null
  };
}
```

**Acceptance Criteria:**
- [ ] Reviewer called after Claude generates plan
- [ ] Patches applied when verdict is 'patch'
- [ ] Telemetry saved asynchronously
- [ ] Review metadata included in response
- [ ] Graceful fallback on reviewer failure

---

#### Task 2.2: Add Stability Cost Metric

**File:** `src/services/openaiReviewer.js`

The `stability_score` is already in the schema. The reviewer prompt includes guidance to calculate it. Add a utility function for the planner to use:

```javascript
/**
 * Calculate a stability score for a plan based on disruption metrics.
 * Higher score = less disruption = better.
 *
 * @param {Object} plan - The reconfiguration plan
 * @param {Object} currentState - Current cellar state
 * @returns {number} Score from 0 to 1
 */
export function calculateStabilityScore(plan, currentState) {
  const actions = plan.actions || [];
  if (actions.length === 0) return 1.0;

  const totalBottles = currentState.totalBottles || 1;
  let bottlesAffected = 0;
  let zonesAffected = new Set();

  for (const action of actions) {
    bottlesAffected += action.bottlesAffected || 0;

    if (action.type === 'reallocate_row') {
      zonesAffected.add(action.fromZoneId);
      zonesAffected.add(action.toZoneId);
    } else if (action.type === 'merge_zones') {
      (action.sourceZones || []).forEach(z => zonesAffected.add(z));
      zonesAffected.add(action.targetZoneId);
    }
  }

  // Penalize based on % of collection affected and number of zones touched
  const bottleRatio = bottlesAffected / totalBottles;
  const zoneRatio = zonesAffected.size / 10; // Assume ~10 zones typical

  // Weight: 70% bottles, 30% zones
  const disruption = (bottleRatio * 0.7) + (zoneRatio * 0.3);

  return Math.max(0, Math.min(1, 1 - disruption));
}
```

**Acceptance Criteria:**
- [ ] Score between 0 and 1
- [ ] Higher score = less disruption
- [ ] Accounts for bottles affected and zones touched

---

### Phase 3: Testing & Observability

#### Task 3.1: Create Sommelier Test Log Document

**File:** `docs/AI_REVIEWER_TEST_LOG.md`

```markdown
# AI Reviewer Test Log

## Purpose
This document tracks AI reviewer performance for sommelier evaluation.
Each entry represents a zone reconfiguration review for quality assessment.

---

## Log Format

### Entry Template
```
## Review #[ID] - [DATE]

**Plan ID:** [plan_id]
**Verdict:** [approve/patch/reject]
**Latency:** [X]ms
**Stability Score:** [0.00-1.00]

### Input Plan (Claude)
- Actions: [count]
- Summary: [brief description]

### Reviewer Assessment
**Violations Found:** [count]
[List violations if any]

**Patches Applied:** [count]
[List patches if any]

**Reasoning:**
> [GPT-5.2's explanation]

### Sommelier Evaluation
- [ ] Plan quality: ___/5
- [ ] Violation detection accuracy: ___/5
- [ ] Patch appropriateness: ___/5
- [ ] Would sommelier approve final plan? [Yes/No]
- Notes: ___
```

---

## Test Entries

[Entries will be added as reviews are performed]

---

## Summary Statistics

| Metric | Value |
|--------|-------|
| Total Reviews | 0 |
| Approved | 0 |
| Patched | 0 |
| Rejected | 0 |
| Avg Latency | - |
| Avg Stability Score | - |
| Sommelier Approval Rate | - |
```

**Acceptance Criteria:**
- [ ] Template created for manual logging
- [ ] Summary statistics section for tracking
- [ ] Clear evaluation criteria for sommelier

---

#### Task 3.2: Add Admin Endpoint for Telemetry Review

**File:** `src/routes/admin.js` (new file or add to existing)

```javascript
/**
 * GET /api/admin/ai-reviews
 * Retrieve recent AI review telemetry for analysis.
 */
router.get('/ai-reviews', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit) || 20, 100);
    const pendingOnly = req.query.pending === 'true';

    let query = `
      SELECT * FROM ai_review_telemetry
      ${pendingOnly ? 'WHERE sommelier_rating IS NULL' : ''}
      ORDER BY created_at DESC
      LIMIT $1
    `;

    const reviews = await db.prepare(query).all([limit]);
    res.json({ data: reviews, count: reviews.length });
  } catch (error) {
    console.error('Error fetching AI reviews:', error);
    res.status(500).json({ error: error.message });
  }
});

/**
 * PATCH /api/admin/ai-reviews/:id/rating
 * Add sommelier rating to a review.
 */
router.patch('/ai-reviews/:id/rating', async (req, res) => {
  try {
    const { id } = req.params;
    const { rating, notes } = req.body;

    if (!rating || rating < 1 || rating > 5) {
      return res.status(400).json({ error: 'Rating must be 1-5' });
    }

    await db.prepare(`
      UPDATE ai_review_telemetry
      SET sommelier_rating = $1,
          sommelier_notes = $2,
          reviewed_by_sommelier_at = NOW()
      WHERE id = $3
    `).run([rating, notes || null, id]);

    res.json({ message: 'Rating saved' });
  } catch (error) {
    console.error('Error saving rating:', error);
    res.status(500).json({ error: error.message });
  }
});
```

**Acceptance Criteria:**
- [ ] List recent reviews with pagination
- [ ] Filter for pending sommelier reviews
- [ ] Add/update sommelier ratings

---

### Phase 4: Rollout

#### Task 4.1: Feature Flag Rollout Steps

1. **Development Testing**
   - Set `OPENAI_REVIEW_ZONE_RECONFIG=true` locally
   - Run zone reconfiguration and verify reviewer is called
   - Check telemetry is saved
   - Verify patches apply correctly

2. **Staging Deployment**
   - Deploy to Railway with flag `false`
   - Enable flag in Railway variables
   - Test with real production data (copy)
   - Review telemetry logs

3. **Production Rollout**
   - Deploy with flag `false`
   - Enable flag during low-usage period
   - Monitor for 24-48 hours
   - Check circuit breaker status
   - Review telemetry for quality

4. **Success Criteria for Full Enablement**
   - Latency < 5 seconds p95
   - No circuit breaker trips
   - Sommelier approval rate > 80%
   - Patch accuracy > 90%

---

## 3. File Summary

| File | Action | Purpose |
|------|--------|---------|
| `src/db/migrations/026_ai_review_telemetry.sql` | Create | Telemetry table |
| `src/services/openaiReviewer.js` | Create | GPT-5.2 review service |
| `src/services/zoneReconfigurationPlanner.js` | Modify | Integrate reviewer |
| `src/routes/admin.js` | Create/Modify | Telemetry endpoints |
| `docs/AI_REVIEWER_TEST_LOG.md` | Create | Sommelier feedback log |
| `.env` | Modify | Add feature flag |

---

## 4. Dependencies

```json
{
  "openai": "^4.x",
  "zod": "^3.x"
}
```

Run: `npm install openai zod`

---

## 5. Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `OPENAI_API_KEY` | OpenAI API key | Required |
| `OPENAI_REVIEW_ZONE_RECONFIG` | Enable reviewer for zone reconfig | `false` |

---

## 6. Latency Targets

| Operation | Target | Max Acceptable |
|-----------|--------|----------------|
| GPT-5.2 Review | 2s | 5s |
| Total Plan Generation | 5s | 10s |
| Telemetry Save | 100ms | 500ms |

---

## 7. Future Expansion

After zone reconfiguration is stable:

1. **Move Suggestions** (`OPENAI_REVIEW_MOVE_SUGGESTIONS`)
   - Review bottle move recommendations
   - Validate zone assignments

2. **Pairing Recommendations** (`OPENAI_REVIEW_PAIRING`)
   - Review food-wine pairings
   - Check for obvious mismatches

Each expansion requires:
- New feature flag
- Tailored Zod schema
- Domain-specific validation rules
- Separate telemetry tracking

---

## 8. Rollback Plan

If issues arise:

1. **Immediate**: Set `OPENAI_REVIEW_ZONE_RECONFIG=false` in Railway
2. **Circuit breaker**: Automatic after 3 failures
3. **Code rollback**: Revert integration in `zoneReconfigurationPlanner.js`

The system always falls back to the original Claude plan + deterministic validation if the reviewer fails.
